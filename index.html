<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <title>List match analyzer</title>
  <meta name="viewport"content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="Client-side tool to analyze semantic similarity between two lists and detect best matches."
  />

  <!-- TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.21.0/dist/tf.min.js"></script>

  <!-- Universal Sentence Encoder -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder@1.3.3/dist/universal-sentence-encoder.min.js"></script>

  <!-- DARK THEME -->
  <style>
    :root {
      --bg: #0f172a;
      --bg-soft: #1f2937;
      --bg-softer: #111827;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.12);
      --accent-strong: rgba(56, 189, 248, 0.3);
      --text: #e5e7eb;
      --text-soft: #9ca3af;
      --border: #374151;
      --danger: #fb7185;
      --radius-lg: 14px;
      --radius-xl: 18px;
      --shadow-soft: 0 18px 45px rgba(15, 23, 42, 0.9);
      --transition-fast: 0.15s ease-out;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background: radial-gradient(circle at top left, #1e293b, #020617);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
      padding: 24px;
    }

    .app {
      width: 100%;
      max-width: 1240px;
      background: linear-gradient(135deg, #020617 0%, #020617 50%, #020617 100%);
      border-radius: 24px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      box-shadow: var(--shadow-soft);
      padding: 22px 24px 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    @media (max-width: 900px) {
      body {
        padding: 12px;
      }
      .app {
        padding: 16px;
        border-radius: 18px;
      }
    }

    .app-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      padding-bottom: 6px;
      border-bottom: 1px solid rgba(55, 65, 81, 0.8);
    }

    .title-block {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .logo-pill {
      width: 34px;
      height: 34px;
      border-radius: 999px;
      background: radial-gradient(circle at 0% 0%, #38bdf8, #0ea5e9 40%, #1d4ed8 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.5),
        0 10px 30px rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
    }

    .logo-pill span {
      font-size: 18px;
      font-weight: 700;
      color: white;
    }

    .title-text h1 {
      font-size: 19px;
      margin: 0 0 2px;
      letter-spacing: 0.01em;
    }

    .title-text p {
      margin: 0;
      font-size: 12px;
      color: var(--text-soft);
    }

    .badge {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.09em;
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      color: #cbd5f5;
      background: radial-gradient(circle at top, #1d283a, #020617);
      display: inline-flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
    }

    .badge-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.12);
    }

    .main-grid {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.1fr);
      gap: 14px;
      align-items: flex-start;
    }

    @media (max-width: 900px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: radial-gradient(circle at top left, #111827, #020617);
      border-radius: var(--radius-xl);
      border: 1px solid rgba(55, 65, 81, 0.95);
      padding: 14px 14px 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      position: relative;
      overflow: hidden;
    }

    .panel::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.1), transparent 60%);
      opacity: 0.7;
      pointer-events: none;
      mix-blend-mode: screen;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 6px;
      position: relative;
      z-index: 1;
    }

    .panel-header h2 {
      font-size: 13px;
      margin: 0;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .panel-header span {
      font-size: 11px;
      color: var(--text-soft);
    }

    .chip {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.09em;
      padding: 3px 7px;
      border-radius: 999px;
      border: 1px solid rgba(107, 114, 128, 0.8);
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .chip span {
      font-size: 12px;
    }

    textarea {
      width: 100%;
      min-height: 170px;
      border-radius: 12px;
      border: 1px solid rgba(55, 65, 81, 0.95);
      background: rgba(15, 23, 42, 0.95);
      color: var(--text);
      padding: 10px 11px;
      font-size: 13px;
      resize: vertical;
      outline: none;
      line-height: 1.4;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      position: relative;
      z-index: 1;
    }

    textarea::placeholder {
      color: rgba(148, 163, 184, 0.6);
      font-size: 12px;
    }

    textarea:focus-visible {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.6),
        0 0 0 16px rgba(56, 189, 248, 0.08);
      background: rgba(15, 23, 42, 0.98);
      outline: none;
    }

    .hint {
      font-size: 11px;
      color: var(--text-soft);
      display: flex;
      align-items: center;
      gap: 6px;
      position: relative;
      z-index: 1;
    }

    .hint-key {
      font-family: ui-monospace, monospace;
      font-size: 10px;
      border-radius: 5px;
      border: 1px solid rgba(75, 85, 99, 0.9);
      padding: 2px 6px;
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
    }

    .controls-column {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .analyze-card {
      background: radial-gradient(circle at top right, #0f172a, #020617);
      border-radius: var(--radius-xl);
      border: 1px solid rgba(55, 65, 81, 0.95);
      padding: 13px 12px 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      position: relative;
      overflow: hidden;
    }

    .analyze-card::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at 10% -10%, rgba(56, 189, 248, 0.45), transparent 45%),
        radial-gradient(circle at 80% 120%, rgba(129, 140, 248, 0.45), transparent 40%);
      opacity: 0.7;
      pointer-events: none;
      mix-blend-mode: screen;
    }

    .analyze-card-inner {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .analyze-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }

    .analyze-title {
      font-size: 13px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .spark {
      width: 26px;
      height: 26px;
      border-radius: 999px;
      border: 1px solid rgba(248, 250, 252, 0.6);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at 30% 0%, #e5e7eb, #38bdf8 40%, #1e3a8a 100%);
      box-shadow: 0 0 0 8px rgba(15, 23, 42, 0.8);
      font-size: 15px;
    }

    .stats-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 11px;
      color: #e5e7eb;
    }

    .stat-pill {
      padding: 4px 7px;
      border-radius: 999px;
      border: 1px solid rgba(15, 23, 42, 0.8);
      background: rgba(15, 23, 42, 0.9);
      display: inline-flex;
      align-items: center;
      gap: 5px;
      backdrop-filter: blur(4px);
      white-space: nowrap;
    }

    .stat-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--accent);
    }

    .analyze-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .button-primary {
      flex: 1;
      min-width: 120px;
      border-radius: 999px;
      border: none;
      padding: 9px 14px;
      font-size: 13px;
      font-weight: 600;
      background: linear-gradient(135deg, #38bdf8, #0ea5e9, #6366f1);
      color: #0b1120;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.8);
      transition: transform var(--transition-fast), box-shadow var(--transition-fast),
        filter var(--transition-fast), opacity var(--transition-fast);
    }

    .button-primary span.icon {
      font-size: 15px;
    }

    .button-primary:hover:not(:disabled) {
      transform: translateY(-1px);
      filter: brightness(1.05);
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.9);
    }

    .button-primary:active:not(:disabled) {
      transform: translateY(0px) scale(0.99);
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.9);
    }

    .button-primary:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
    }

    .button-primary:focus-visible,
    .chip:focus-visible,
    .tab-button:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .small-note {
      font-size: 10px;
      color: var(--text-soft);
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .small-note strong {
      font-weight: 600;
      color: #e5e7eb;
    }

    .small-note span {
      display: inline-flex;
      align-items: center;
      gap: 5px;
    }

    .tiny-dot {
      width: 5px;
      height: 5px;
      border-radius: 999px;
      background: var(--accent);
    }

    /* RESULTS */

    .results-card {
      background: radial-gradient(circle at bottom left, #020617, #020617 50%, #020617 100%);
      border-radius: var(--radius-xl);
      border: 1px solid rgba(55, 65, 81, 0.95);
      padding: 14px 13px 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      position: relative;
      overflow: hidden;
      min-height: 130px;
    }

    .results-card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at bottom left, rgba(56, 189, 248, 0.2), transparent 55%);
      opacity: 0.5;
      pointer-events: none;
      mix-blend-mode: screen;
    }

    .results-header {
      position: relative;
      z-index: 1;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .results-header-left {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .results-header-left h2 {
      font-size: 13px;
      margin: 0;
      font-weight: 600;
    }

    .results-header-left p {
      font-size: 11px;
      margin: 0;
      color: var(--text-soft);
    }

    .results-badge {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      padding: 4px 7px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.96);
      display: inline-flex;
      align-items: center;
      gap: 5px;
      white-space: nowrap;
    }

    .results-tabs {
      position: relative;
      z-index: 1;
      display: inline-flex;
      padding: 3px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(55, 65, 81, 0.9);
      gap: 2px;
    }

    .tab-button {
      border-radius: 999px;
      border: none;
      padding: 4px 10px;
      font-size: 11px;
      cursor: pointer;
      background: transparent;
      color: var(--text-soft);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background var(--transition-fast), color var(--transition-fast),
        transform var(--transition-fast), box-shadow var(--transition-fast);
      white-space: nowrap;
    }

    .tab-button span.count {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
    }

    .tab-button.active {
      background: linear-gradient(135deg, rgba(56, 189, 248, 0.18), rgba(59, 130, 246, 0.22));
      color: #e5e7eb;
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.7);
      transform: translateY(-0.5px);
    }

    .results-body {
      position: relative;
      z-index: 1;
      margin-top: 4px;
    }

    .results-list {
      display: none;
      max-height: 260px;
      overflow: auto;
      padding-right: 3px;
    }

    .results-list.active {
      display: block;
    }

    .match-row {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 32px minmax(0, 1fr);
      gap: 6px;
      align-items: stretch;
      margin-bottom: 6px;
    }

    @media (max-width: 700px) {
      .match-row {
        grid-template-columns: 1fr;
      }
    }

    .item-card {
      border-radius: 11px;
      border: 1px solid rgba(55, 65, 81, 0.95);
      background: rgba(15, 23, 42, 0.96);
      padding: 7px 8px 7px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .item-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-soft);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .item-label strong {
      color: #e5e7eb;
      font-weight: 600;
    }

    .item-text {
      font-size: 12px;
      line-height: 1.35;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .score-pill {
      font-size: 10px;
      border-radius: 999px;
      padding: 2px 6px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(55, 65, 81, 0.9);
      color: var(--text-soft);
    }

    .score-pill strong {
      color: #e5e7eb;
    }

    .arrow-cell {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      color: rgba(148, 163, 184, 0.9);
    }

    .arrow-pill {
      width: 24px;
      height: 24px;
      border-radius: 999px;
      border: 1px solid rgba(75, 85, 99, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(15, 23, 42, 0.96);
    }

    .empty-state {
      font-size: 12px;
      color: var(--text-soft);
      text-align: left;
      padding: 5px 1px 2px;
    }

    .footer {
      margin-top: -2px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 10px;
      color: var(--text-soft);
      padding-top: 4px;
      border-top: 1px solid rgba(31, 41, 55, 0.9);
      flex-wrap: wrap;
    }

    .footer span {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .footer-code {
      font-family: ui-monospace, monospace;
      font-size: 10px;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      padding: 2px 7px;
      background: rgba(15, 23, 42, 0.96);
      color: var(--text-soft);
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
  </style>

  <!-- LIGHT THEME -->
  <style>
    :root {
      --bg: #f3f4f6;
      --bg-soft: #ffffff;
      --bg-softer: #e5e7eb;
      --accent: #3b82f6;
      --accent-soft: rgba(59, 130, 246, 0.12);
      --accent-strong: rgba(59, 130, 246, 0.28);
      --text: #111827;
      --text-soft: #6b7280;
      --border: #e5e7eb;
      --danger: #ef4444;
      --radius-lg: 14px;
      --radius-xl: 18px;
      --shadow-soft: 0 18px 45px rgba(15, 23, 42, 0.08);
      --transition-fast: 0.15s ease-out;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background: radial-gradient(circle at top left, #e0f2fe, #f9fafb);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
      padding: 24px;
    }

    .app {
      width: 100%;
      max-width: 1240px;
      background: linear-gradient(
        135deg,
        #ffffff 0%,
        #f9fafb 40%,
        #eff6ff 100%
      );
      border-radius: 24px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      box-shadow: var(--shadow-soft);
      padding: 22px 24px 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    @media (max-width: 900px) {
      body {
        padding: 12px;
      }
      .app {
        padding: 16px;
        border-radius: 18px;
      }
    }

    .app-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      padding-bottom: 6px;
      border-bottom: 1px solid rgba(209, 213, 219, 0.9);
    }

    .title-block {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .logo-pill {
      width: 34px;
      height: 34px;
      border-radius: 999px;
      background: conic-gradient(
        from 180deg,
        #f97316,
        #ec4899,
        #6366f1,
        #22c55e,
        #f97316
      );
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow:
        0 0 0 2px rgba(59, 130, 246, 0.35),
        0 10px 25px rgba(15, 23, 42, 0.18);
      flex-shrink: 0;
    }

    .logo-pill span {
      font-size: 18px;
      font-weight: 700;
      color: white;
    }

    .title-text h1 {
      font-size: 19px;
      margin: 0 0 2px;
      letter-spacing: 0.01em;
      color: var(--text);
    }

    .title-text p {
      margin: 0;
      font-size: 12px;
      color: var(--text-soft);
    }

    .badge {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.09em;
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      color: #0369a1;
      background: radial-gradient(circle at top, #e0f2fe, #ffffff);
      display: inline-flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
    }

    .badge-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #22c55e;
    }

    .main-grid {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.1fr);
      gap: 14px;
      align-items: flex-start;
    }

    @media (max-width: 900px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: radial-gradient(circle at top left, #eff6ff, #ffffff);
      border-radius: var(--radius-xl);
      border: 1px solid var(--border);
      padding: 14px 14px 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      position: relative;
      overflow: hidden;
    }

    .panel::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(
        circle at top left,
        rgba(59, 130, 246, 0.15),
        transparent 60%
      );
      opacity: 0.8;
      pointer-events: none;
      mix-blend-mode: screen;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 6px;
      position: relative;
      z-index: 1;
    }

    .panel-header h2 {
      font-size: 13px;
      margin: 0;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
      color: var(--text);
    }

    .panel-header span {
      font-size: 11px;
      color: var(--text-soft);
    }

    .chip {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.09em;
      padding: 3px 7px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.9);
      color: var(--text-soft);
      background: #f9fafb;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .chip span {
      font-size: 12px;
    }

    textarea {
      width: 100%;
      min-height: 170px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #ffffff;
      color: var(--text);
      padding: 10px 11px;
      font-size: 13px;
      resize: vertical;
      outline: none;
      line-height: 1.4;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      position: relative;
      z-index: 1;
    }

    textarea::placeholder {
      color: rgba(156, 163, 175, 0.9);
      font-size: 12px;
    }

    textarea:focus-visible {
      border-color: var(--accent);
      box-shadow:
        0 0 0 1px rgba(59, 130, 246, 0.7),
        0 0 0 10px rgba(59, 130, 246, 0.1);
      background: #ffffff;
      outline: none;
    }

    .hint {
      font-size: 11px;
      color: var(--text-soft);
      display: flex;
      align-items: center;
      gap: 6px;
      position: relative;
      z-index: 1;
    }

    .hint-key {
      font-family: ui-monospace, monospace;
      font-size: 10px;
      border-radius: 5px;
      border: 1px solid rgba(209, 213, 219, 0.9);
      padding: 2px 6px;
      background: #ffffff;
      color: #111827;
    }

    .controls-column {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .analyze-card {
      background: radial-gradient(circle at top right, #eef2ff, #fff7ed);
      border-radius: var(--radius-xl);
      border: 1px solid var(--border);
      padding: 13px 12px 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      position: relative;
      overflow: hidden;
    }

    .analyze-card::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at 10% -10%, rgba(59, 130, 246, 0.45), transparent 45%),
        radial-gradient(circle at 80% 120%, rgba(244, 114, 182, 0.45), transparent 40%);
      opacity: 0.6;
      pointer-events: none;
      mix-blend-mode: screen;
    }

    .analyze-card-inner {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .analyze-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }

    .analyze-title {
      font-size: 13px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text);
    }

    .spark {
      width: 26px;
      height: 26px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.8);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(
        circle at 30% 0%,
        #fefce8,
        #fbbf24 40%,
        #f97316 100%
      );
      box-shadow: 0 0 0 6px rgba(251, 191, 36, 0.25);
      font-size: 15px;
    }

    .stats-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 11px;
      color: var(--text);
    }

    .stat-pill {
      padding: 4px 7px;
      border-radius: 999px;
      border: 1px solid rgba(209, 213, 219, 0.9);
      background: rgba(249, 250, 251, 0.95);
      display: inline-flex;
      align-items: center;
      gap: 5px;
      backdrop-filter: blur(4px);
      white-space: nowrap;
    }

    .stat-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--accent);
    }

    .analyze-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .button-primary {
      flex: 1;
      min-width: 120px;
      border-radius: 999px;
      border: none;
      padding: 9px 14px;
      font-size: 13px;
      font-weight: 600;
      background: linear-gradient(135deg, #3b82f6, #6366f1, #ec4899);
      color: #ffffff;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 12px 24px rgba(129, 140, 248, 0.35);
      transition:
        transform var(--transition-fast),
        box-shadow var(--transition-fast),
        filter var(--transition-fast),
        opacity var(--transition-fast);
    }

    .button-primary span.icon {
      font-size: 15px;
    }

    .button-primary:hover:not(:disabled) {
      transform: translateY(-1px);
      filter: brightness(1.05);
      box-shadow: 0 18px 32px rgba(129, 140, 248, 0.45);
    }

    .button-primary:active:not(:disabled) {
      transform: translateY(0px) scale(0.99);
      box-shadow: 0 8px 18px rgba(129, 140, 248, 0.4);
    }

    .button-primary:disabled {
      opacity: 0.55;
      cursor: default;
      box-shadow: none;
    }

    .button-primary:focus-visible,
    .chip:focus-visible,
    .tab-button:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .small-note {
      font-size: 10px;
      color: var(--text-soft);
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .small-note strong {
      font-weight: 600;
      color: var(--text);
    }

    .small-note span {
      display: inline-flex;
      align-items: center;
      gap: 5px;
    }

    .tiny-dot {
      width: 5px;
      height: 5px;
      border-radius: 999px;
      background: var(--accent);
    }

    /* RESULTS */

    .results-card {
      background: radial-gradient(circle at bottom left, #ffffff, #f9fafb 55%);
      border-radius: var(--radius-xl);
      border: 1px solid var(--border);
      padding: 14px 13px 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      position: relative;
      overflow: hidden;
      min-height: 130px;
    }

    .results-card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(
        circle at bottom left,
        rgba(59, 130, 246, 0.22),
        transparent 60%
      );
      opacity: 0.5;
      pointer-events: none;
      mix-blend-mode: screen;
    }

    .results-header {
      position: relative;
      z-index: 1;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .results-header-left {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .results-header-left h2 {
      font-size: 13px;
      margin: 0;
      font-weight: 600;
      color: var(--text);
    }

    .results-header-left p {
      font-size: 11px;
      margin: 0;
      color: var(--text-soft);
    }

    .results-badge {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      padding: 4px 7px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.8);
      background: #eff6ff;
      display: inline-flex;
      align-items: center;
      gap: 5px;
      white-space: nowrap;
      color: #1d4ed8;
    }

    .results-tabs {
      position: relative;
      z-index: 1;
      display: inline-flex;
      padding: 3px;
      border-radius: 999px;
      background: #f3f4f6;
      border: 1px solid rgba(209, 213, 219, 0.9);
      gap: 2px;
    }

    .tab-button {
      border-radius: 999px;
      border: none;
      padding: 4px 10px;
      font-size: 11px;
      cursor: pointer;
      background: transparent;
      color: var(--text-soft);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition:
        background var(--transition-fast),
        color var(--transition-fast),
        transform var(--transition-fast),
        box-shadow var(--transition-fast);
      white-space: nowrap;
    }

    .tab-button span.count {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      background: #e5e7eb;
    }

    .tab-button.active {
      background: linear-gradient(
        135deg,
        rgba(59, 130, 246, 0.18),
        rgba(96, 165, 250, 0.25)
      );
      color: #1f2937;
      box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.8);
      transform: translateY(-0.5px);
    }

    .results-body {
      position: relative;
      z-index: 1;
      margin-top: 4px;
    }

    .results-list {
      display: none;
      max-height: 260px;
      overflow: auto;
      padding-right: 3px;
    }

    .results-list.active {
      display: block;
    }

    .match-row {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 32px minmax(0, 1fr);
      gap: 6px;
      align-items: stretch;
      margin-bottom: 6px;
    }

    @media (max-width: 700px) {
      .match-row {
        grid-template-columns: 1fr;
      }
    }

    .item-card {
      border-radius: 11px;
      border: 1px solid var(--border);
      background: #f9fafb;
      padding: 7px 8px 7px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .item-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-soft);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .item-label strong {
      color: var(--text);
      font-weight: 600;
    }

    .item-text {
      font-size: 12px;
      line-height: 1.35;
      white-space: pre-wrap;
      word-wrap: break-word;
      color: var(--text);
    }

    .score-pill {
      font-size: 10px;
      border-radius: 999px;
      padding: 2px 6px;
      background: #ffffff;
      border: 1px solid rgba(209, 213, 219, 0.9);
      color: var(--text-soft);
    }

    .score-pill strong {
      color: var(--text);
    }

    .arrow-cell {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      color: rgba(148, 163, 184, 0.9);
    }

    .arrow-pill {
      width: 24px;
      height: 24px;
      border-radius: 999px;
      border: 1px solid rgba(209, 213, 219, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      background: #ffffff;
    }

    .empty-state {
      font-size: 12px;
      color: var(--text-soft);
      text-align: left;
      padding: 5px 1px 2px;
    }

    .footer {
      margin-top: -2px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 10px;
      color: var(--text-soft);
      padding-top: 4px;
      border-top: 1px solid rgba(229, 231, 235, 0.9);
      flex-wrap: wrap;
    }

    .footer span {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .footer-code {
      font-family: ui-monospace, monospace;
      font-size: 10px;
      border-radius: 999px;
      border: 1px solid rgba(209, 213, 219, 0.9);
      padding: 2px 7px;
      background: #f9fafb;
      color: var(--text-soft);
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
  </style>
</head>
<body>
  <main class="app" role="main">
    <header class="app-header" aria-label="List matching tool header">
      <div class="title-block">
        <div class="logo-pill" aria-hidden="true">
          <span>Œ£</span>
        </div>
        <div class="title-text">
          <h1>List match analyzer</h1>
          <p>
            Matches the items of two lists using a hybrid semantic model (USE / TF-IDF + fuzzy, optional glossary).
          </p>
        </div>
      </div>
      <div class="header-actions">
        <div class="badge">
          <span class="badge-dot" aria-hidden="true"></span>
          <span>Local ¬∑ 100% in your browser</span>
        </div>
        <!-- Theme toggle button is injected here -->
      </div>
    </header>

    <div class="main-grid" aria-label="Input lists">
      <!-- LIST 1 -->
      <section class="panel" aria-labelledby="listAHeading">
        <div class="panel-header">
          <div>
            <h2 id="listAHeading">
              <span>List 1</span>
              <span>(source A)</span>
            </h2>
            <span class="hint" id="listAHint">
              <span class="hint-key">Enter ‚Üµ</span>
              <span>1 item per line</span>
            </span>
          </div>
          <div class="chip">
            <span>‚ë†</span>
            <span>Input</span>
          </div>
        </div>
        <textarea
          id="listA"
          aria-labelledby="listAHeading"
          aria-describedby="listAHint"
          placeholder="Example:
Java backend developer
Digital project manager
Senior data analyst
Cybersecurity consultant

Each line is treated as a separate item."
        ></textarea>
      </section>

      <!-- LIST 2 -->
      <section class="panel" aria-labelledby="listBHeading">
        <div class="panel-header">
          <div>
            <h2 id="listBHeading">
              <span>List 2</span>
              <span>(source B)</span>
            </h2>
            <span class="hint" id="listBHint">
              <span class="hint-key">Enter ‚Üµ</span>
              <span>1 item per line</span>
            </span>
          </div>
          <div class="chip">
            <span>‚ë°</span>
            <span>Reference</span>
          </div>
        </div>
        <textarea
          id="listB"
          aria-labelledby="listBHeading"
          aria-describedby="listBHint"
          placeholder="Example:
Java software engineer
Web project lead
Data analyst
Information security consultant"
        ></textarea>
      </section>
    </div>

    <div class="main-grid" style="margin-top: 4px;">
      <div class="controls-column">
        <!-- GLOSSARY PANEL -->
        <section class="panel" aria-labelledby="glossaryHeading">
          <div class="panel-header">
            <div>
              <h2 id="glossaryHeading">Glossary (optional)</h2>
              <span class="hint" id="glossaryHint">
                <span class="hint-key">key = value</span>
                <span>1 mapping per line ¬∑ synonyms, abbreviations, normalizations</span>
              </span>
            </div>
            <div class="chip">
              <span>‚ìò</span>
              <span>Semantic glossary</span>
            </div>
          </div>

          <textarea
            id="glossary"
            aria-labelledby="glossaryHeading"
            aria-describedby="glossaryHint"
            placeholder="Examples:
PM = Digital project manager
Dev backend = Java backend developer
Info sec = Information security consultant

Each line:
LEFT (synonym or variant) = RIGHT (canonical term)
You can also define abbreviations or translations."
          ></textarea>

          <label class="hint" style="margin-top: 4px; cursor: pointer;">
            <span class="hint-key">.txt</span>
            <span>Import a glossary file (.txt)</span>
            <input
              id="glossaryFile"
              type="file"
              accept=".txt"
              style="display:none;"
            />
          </label>
        </section>

        <!-- ANALYZE CARD -->
        <section
          class="analyze-card"
          aria-label="Semantic analysis configuration"
        >
          <div class="analyze-card-inner">
            <div class="analyze-header">
              <div class="analyze-title">
                <div class="spark" aria-hidden="true">‚ú¶</div>
                <div>Semantic analysis with optional glossary</div>
              </div>
              <span class="results-badge">
                Hybrid model ¬∑ USE / TF-IDF ¬∑ Fuzzy ¬∑ Glossary
              </span>
            </div>
            <div class="stats-row" id="statsRow" aria-live="polite">
              <div class="stat-pill">
                <span class="stat-dot" aria-hidden="true"></span>
                <span id="stats-counts">
                  0 item(s) in list 1 ¬∑ 0 item(s) in list 2
                </span>
              </div>
              <div class="stat-pill">
                <span aria-hidden="true">üìö</span>
                <span id="stats-vocab">
                  Vocabulary: ‚Äî distinct terms
                </span>
              </div>
              <div class="stat-pill">
                <span aria-hidden="true">üéØ</span>
                <span id="stats-threshold">
                  Match threshold: 0.35
                </span>
              </div>
            </div>
            <div class="analyze-footer">
              <button
                id="analyzeBtn"
                class="button-primary"
                type="button"
              >
                <span class="icon" aria-hidden="true">‚ûú</span>
                <span>Run matching analysis</span>
              </button>
              <div class="small-note" aria-live="polite">
                <span>
                  <strong>How does it work?</strong>
                </span>
                <span>
                  <span class="tiny-dot" aria-hidden="true"></span>
                  <span>Optional glossary expansion, text cleaning, stopword removal, TF-IDF weighting</span>
                </span>
                <span>
                  <span class="tiny-dot" aria-hidden="true"></span>
                  <span>Hybrid similarity (Universal Sentence Encoder when available, otherwise TF-IDF + fuzzy matching)</span>
                </span>
              </div>
            </div>
          </div>
        </section>
      </div>

      <!-- RESULTS -->
      <section
        class="results-card"
        aria-label="Matching results"
        role="region"
      >
        <div class="results-header">
          <div class="results-header-left">
            <h2>Detected results &amp; matches</h2>
            <p
              id="resultsSummary"
              role="status"
              aria-live="polite"
            >
              Matches will appear here after the analysis.
            </p>
          </div>
          <div
            class="results-tabs"
            role="tablist"
            aria-label="Result views"
          >
            <button
              id="tab-viewA"
              class="tab-button active"
              data-tab="viewA"
              role="tab"
              aria-selected="true"
              aria-controls="viewA"
              tabindex="0"
            >
              <span>View by list 1</span>
              <span class="count" id="countA">0</span>
            </button>
            <button
              id="tab-viewB"
              class="tab-button"
              data-tab="viewB"
              role="tab"
              aria-selected="false"
              aria-controls="viewB"
              tabindex="-1"
            >
              <span>View by list 2</span>
              <span class="count" id="countB">0</span>
            </button>
          </div>
        </div>

        <div class="results-body">
          <div
            id="viewA"
            class="results-list active"
            role="tabpanel"
            aria-labelledby="tab-viewA"
            tabindex="0"
          ></div>
          <div
            id="viewB"
            class="results-list"
            role="tabpanel"
            aria-labelledby="tab-viewB"
            tabindex="0"
          ></div>
        </div>

        <footer class="footer">
          <span>
            ‚ú≥Ô∏è All processing happens locally in your browser; no data is sent to a server.
          </span>
          <span class="footer-code">
            Hybrid similarity using USE (if available) or TF-IDF + fuzzy matching, with optional glossary expansion
          </span>
        </footer>
      </section>
    </div>
  </main>

  <script>
    // ---------------------------------------------------
    // Text utilities & TF-IDF / cosine implementation
    // ---------------------------------------------------

    const MATCH_THRESHOLD = 0.22;

    // Basic English and French stopword lists (can be extended)
    const STOPWORDS_FR = new Set([
      "le","la","les","un","une","des","de","du","au","aux","en","dans","sur","sous","par",
      "pour","avec","sans","entre","et","ou","mais","donc","or","ni","car",
      "je","tu","il","elle","on","nous","vous","ils","elles",
      "ce","cet","cette","ces","mon","ma","mes","ton","ta","tes","son","sa","ses",
      "notre","nos","votre","vos","leur","leurs",
      "qui","que","quoi","dont","o√π",
      "ne","pas","plus","moins","tr√®s","trop","bien","mal",
      "deux","trois","quatre","cinq","six","sept","huit","neuf","dix",
      "est","sont","√™tre","√©t√©","avoir","fait","faites",
      "aujourd","hui"
    ]);

    const STOPWORDS_EN = new Set([
      "the","a","an","of","in","on","at","for","to","from","by","and","or","but","so",
      "i","you","he","she","we","they","it",
      "this","that","these","those","my","your","his","her","its","our","their",
      "is","are","was","were","be","been","being",
      "with","without","into","over","under","about","as","than","then",
      "very","too","just","more","less"
    ]);

function normalizeText(text) {
  return (text || "")
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")        // enlever accents
    .replace(/[^a-z0-9'\s-]/g, " ");        // ICI : \s et pas \\s
}

    function simpleStem(token) {
      let t = token;
      // Very rough French suffixes
      t = t.replace(/(ements?|ations?|tions?|rices?|teurs?|euses?|euse|ment|tion|sion|ance|ence|ites?|iques?)$/i, "");
      // Very rough English suffixes
      t = t.replace(/(ing|ingly|ed|er|ers)$/i, "");
      // Basic plural handling
      t = t.replace(/(s)$/i, "");
      return t || token;
    }

function tokenize(text) {
  const normalized = normalizeText(text);
  const rawTokens = normalized.split(/\s+/).filter(Boolean); // ICI : \s+
  const tokens = [];
  for (const tok of rawTokens) {
    if (STOPWORDS_FR.has(tok) || STOPWORDS_EN.has(tok)) continue;
    const stemmed = simpleStem(tok);
    if (stemmed.length < 2) continue;
    tokens.push(stemmed);
  }
  return tokens;
}

    function computeTfidfVectors(documentsTokens) {
      const vocabIndex = new Map();
      let index = 0;

      // Build vocabulary
      for (const tokens of documentsTokens) {
        for (const t of new Set(tokens)) {
          if (!vocabIndex.has(t)) {
            vocabIndex.set(t, index++);
          }
        }
      }

      const N = documentsTokens.length;
      const V = vocabIndex.size;

      if (N === 0 || V === 0) {
        return { vectors: [], vocabIndex, vocabSize: V };
      }

      const df = new Array(V).fill(0);

      // Document frequency
      for (const tokens of documentsTokens) {
        const seen = new Set();
        for (const t of tokens) {
          const idx = vocabIndex.get(t);
          if (idx == null) continue;
          if (!seen.has(idx)) {
            df[idx]++;
            seen.add(idx);
          }
        }
      }

      const idf = df.map((d) => Math.log(1 + N / (1 + d)));

      // TF-IDF vectors (L2-normalized)
      const vectors = documentsTokens.map((tokens) => {
        const vec = new Float32Array(V);
        if (tokens.length === 0) return vec;
        const counts = new Map();
        for (const t of tokens) {
          const idx = vocabIndex.get(t);
          if (idx == null) continue;
          counts.set(idx, (counts.get(idx) || 0) + 1);
        }
        const len = tokens.length;
        for (const [idx, c] of counts) {
          const tf = c / len;
          vec[idx] = tf * idf[idx];
        }
        let norm = 0;
        for (let i = 0; i < V; i++) norm += vec[i] * vec[i];
        norm = Math.sqrt(norm) || 1;
        for (let i = 0; i < V; i++) vec[i] /= norm;
        return vec;
      });

      return { vectors, vocabIndex, vocabSize: V };
    }

    function cosineSimilarity(vecA, vecB) {
      if (!vecA || !vecB || vecA.length !== vecB.length) return 0;
      let dot = 0;
      for (let i = 0; i < vecA.length; i++) {
        dot += vecA[i] * vecB[i];
      }
      return dot;
    }

    // ---------------------------------------------------
    // Character-based fuzzy similarity (Levenshtein)
    // ---------------------------------------------------

    function levenshteinDistance(a, b) {
      const s = (a || "").toLowerCase();
      const t = (b || "").toLowerCase();
      const m = s.length;
      const n = t.length;
      if (m === 0) return n;
      if (n === 0) return m;

      const dp = Array.from({ length: m + 1 }, () => new Array(n + 1));

      for (let i = 0; i <= m; i++) dp[i][0] = i;
      for (let j = 0; j <= n; j++) dp[0][j] = j;

      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          const cost = s[i - 1] === t[j - 1] ? 0 : 1;
          dp[i][j] = Math.min(
            dp[i - 1][j] + 1,
            dp[i][j - 1] + 1,
            dp[i - 1][j - 1] + cost
          );
        }
      }
      return dp[m][n];
    }

    function fuzzySimilarity(strA, strB) {
      const a = (strA || "").trim();
      const b = (strB || "").trim();
      if (!a && !b) return 1;
      if (!a || !b) return 0;

      const maxLen = Math.max(a.length, b.length);
      if (maxLen === 0) return 1;

      const dist = levenshteinDistance(a, b);
      return 1 - dist / maxLen;
    }

    // ---------------------------------------------------
    // Glossary: parsing & application
    // ---------------------------------------------------

    // Expected format per line: "key = value" or "key: value"
    // Example:
    //   PM = Digital project manager
    //   Dev backend: Java backend developer
    function parseGlossary(text) {
      return (text || "")
        .split(/\r?\n/)             // ICI aussi
        .map((line) => line.trim())
        .filter((line) => line.length > 0 && !line.startsWith("#"))
        .map((line) => {
          const parts = line.split(/[:=]/);
          if (parts.length < 2) return null;
          const from = parts[0].trim().toLowerCase();
          const to = parts.slice(1).join(":").trim();
          if (!from || !to) return null;
          return { from, to };
        })
        .filter(Boolean);
    }

    // We do not replace the text, we "enrich" each sentence
    // by appending the canonical term when the key appears.
    // Example:
    //   sentence: "PM digital"
    //   glossary: "PM = Digital project manager"
    //   -> "PM digital Digital project manager"
    function applyGlossaryToSentence(sentence, glossaryPairs) {
      if (!glossaryPairs || glossaryPairs.length === 0) return sentence;
      let result = sentence || "";
      const lower = (sentence || "").toLowerCase();

      for (const pair of glossaryPairs) {
        if (!pair || !pair.from) continue;
        if (lower.includes(pair.from)) {
          result += " " + pair.to;
        }
      }
      return result;
    }

    // ---------------------------------------------------
    // Hybrid model: USE (if available) + TF-IDF + fuzzy
    // ---------------------------------------------------

    let useModelPromise = null;

    async function getUseModel() {
      if (!useModelPromise) {
        useModelPromise = use.load(); // global from universal-sentence-encoder
      }
      return useModelPromise;
    }
    
// Estime automatiquement combien de comparaisons USE on accepte
function estimateMaxUseComparisons() {
  // base "moyenne" pour un laptop correcte
  let base = 20000;

  // 1) Adapter en fonction du nombre de c≈ìurs
  const cores = (navigator && navigator.hardwareConcurrency) || 4;
  // On plafonne √† 8 c≈ìurs pour √©viter les exc√®s
  const coreFactor = Math.min(cores, 8) / 4; // 4 c≈ìurs = factor 1
  base *= coreFactor;

  // 2) D√©tecter (grossi√®rement) le mobile
  const ua = (navigator && navigator.userAgent) || "";
  const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(ua);
  if (isMobile) {
    base *= 0.5; // on divise par 2 sur mobile
  }

  // 3) Utiliser la m√©moire si dispo (Chrome, Edge, etc.)
  // deviceMemory est en Go (2, 4, 8, 16‚Ä¶)
  const mem = navigator.deviceMemory || 4;
  if (mem <= 2) {
    base *= 0.5; // petites machines
  } else if (mem >= 8) {
    base *= 1.5; // grosses machines
  }

  // 4) bornes de s√©curit√© (√©viter les valeurs d√©biles)
  base = Math.max(base, 8000);   // minimum 8k comparaisons
  base = Math.min(base, 80000);  // maximum 80k comparaisons

  const maxComparisons = Math.round(base);
  console.log("[List matcher] MAX_USE_COMPARISONS auto =", maxComparisons);
  return maxComparisons;
}

// ------------------------------------------------------------
// Estimation automatique du budget USE selon la machine
// ------------------------------------------------------------
function estimateMaxUseComparisons() {
  let base = 20000; // valeur de d√©part

  // 1) CPU
  const cores = navigator.hardwareConcurrency || 4;
  const coreFactor = Math.min(cores, 8) / 4;
  base *= coreFactor;

  // 2) Mobile = beaucoup plus petit
  const ua = navigator.userAgent || "";
  const isMobile = /Mobi|Android|iPhone|iPad/i.test(ua);
  if (isMobile) base *= 0.5;

  // 3) RAM si dispo (Chrome etc.)
  const mem = navigator.deviceMemory || 4;
  if (mem <= 2) base *= 0.5;
  else if (mem >= 8) base *= 1.5;

  // 4) Bornes de s√©curit√©
  base = Math.max(8000, Math.min(base, 80000));

  const result = Math.round(base);
  console.log("[AUTO] MAX_USE_COMPARISONS =", result);
  return result;
}

function estimateUseLimit() {
  let base = 8000;

  const cores = navigator.hardwareConcurrency || 4;
  const mem   = navigator.deviceMemory || 4;
  const ua    = navigator.userAgent || "";
  const isMobile = /Mobi|Android|iPhone|iPad/i.test(ua);

  // CPU
  base *= Math.min(cores, 8) / 4;

  // RAM
  if (mem >= 8) base *= 1.5;
  if (mem <= 2) base *= 0.5;

  // Mobile = plus prudent
  if (isMobile) base *= 0.6;

  // Bornes
  base = Math.max(4000, Math.min(base, 50000));

  const limit = Math.round(base);
  console.log("[AUTO] USE limit =", limit, "comparisons (nA * nB)");
  return limit;
}

// ------------------------------------------------------------
// computeMatches() ‚Äî VERSION AUTO + OPTIMIS√âE
// ------------------------------------------------------------
async function computeMatches(listA, listB, threshold, onProgress) {
  const progress = typeof onProgress === "function" ? onProgress : () => {};

  const nA = listA.length;
  const nB = listB.length;

  // Rien √† comparer
  if (nA === 0 || nB === 0) {
    updateStats(nA, nB, 0, threshold);
    return {
      matchesFromA: [],
      matchesFromB: [],
      vocabSize: 0
    };
  }

  const canUseUSE = typeof use !== "undefined" && typeof tf !== "undefined";
  const useLimit = estimateUseLimit(); // limite dynamique pour USE

  // ------------------------------------------------------------
  // 1) Tentative USE (si dispo + taille raisonnable)
  // ------------------------------------------------------------
  if (canUseUSE && nA * nB <= useLimit) {
    try {
      progress({ phase: "USE", done: 0, total: 1 });

      const model = await getUseModel();
      const allSentences = [...listA, ...listB];
      const embeddings = await model.embed(allSentences);
      const dim = embeddings.shape[1];

      const result = tf.tidy(() => {
        const embA = embeddings.slice([0, 0], [nA, dim]);
        const embB = embeddings.slice([nA, 0], [nB, dim]);

        const normA = embA.norm("euclidean", 1).expandDims(1);
        const normB = embB.norm("euclidean", 1).expandDims(1);

        const embA_norm = embA.div(normA);
        const embB_norm = embB.div(normB);

        const simMatrix = embA_norm.matMul(embB_norm, false, true);
        const sims = simMatrix.arraySync(); // [nA][nB]

        const matchesFromA = [];
        const matchesFromB = [];

        // A -> B
        for (let i = 0; i < nA; i++) {
          let bestScore = -1;
          let bestIdx = null;
          for (let j = 0; j < nB; j++) {
            const score = sims[i][j];
            if (score > bestScore) {
              bestScore = score;
              bestIdx = j;
            }
          }
          matchesFromA.push({
            fromIndex: i,
            toIndex: bestScore >= threshold ? bestIdx : null,
            score: bestScore
          });
        }

        // B -> A
        for (let j = 0; j < nB; j++) {
          let bestScore = -1;
          let bestIdx = null;
          for (let i = 0; i < nA; i++) {
            const score = sims[i][j];
            if (score > bestScore) {
              bestScore = score;
              bestIdx = i;
            }
          }
          matchesFromB.push({
            fromIndex: j,
            toIndex: bestScore >= threshold ? bestIdx : null,
            score: bestScore
          });
        }

        return { matchesFromA, matchesFromB };
      });

      embeddings.dispose();

      progress({ phase: "USE", done: 1, total: 1 });
      updateStats(nA, nB, 0, threshold);

      return {
        matchesFromA: result.matchesFromA,
        matchesFromB: result.matchesFromB,
        vocabSize: 0
      };
    } catch (err) {
      console.error("USE failed, fallback TF-IDF:", err);
      // on tombe sur TF-IDF ci-dessous
    }
  }

  // ------------------------------------------------------------
  // 2) TF-IDF + fuzzy avec BATCH dynamique
  // ------------------------------------------------------------
  progress({ phase: "prepare", done: 0, total: 3 });

  const listTokensA = listA.map(tokenize);
  const listTokensB = listB.map(tokenize);
  const allTokens   = [...listTokensA, ...listTokensB];

  const { vectors, vocabSize } = computeTfidfVectors(allTokens);

  const vecA = vectors.slice(0, nA);
  const vecB = vectors.slice(nA);

  progress({ phase: "prepare", done: 1, total: 3 });

  const matchesFromA = [];
  const matchesFromB = [];

  const alpha = 0.6; // TF-IDF
  const beta  = 0.4; // fuzzy

  // Batch dynamique
  let batchSize       = 16;
  const minBatch      = 4;
  const maxBatch      = 256;
  const targetChunkMs = 30; // temps de travail vis√© avant de rendre la main

  let lastYield = performance.now();
  let iterSinceYield = 0;

  // ---------------- A -> B ----------------
  for (let i = 0; i < nA; i++) {
    let bestScore = 0;
    let bestIdx = null;

    for (let j = 0; j < nB; j++) {
      const s1 = cosineSimilarity(vecA[i], vecB[j]);
      const s2 = fuzzySimilarity(listA[i], listB[j]);
      const score = alpha * s1 + beta * s2;
      if (score > bestScore) {
        bestScore = score;
        bestIdx = j;
      }
    }

    matchesFromA.push({
      fromIndex: i,
      toIndex: bestScore >= threshold ? bestIdx : null,
      score: bestScore
    });

    iterSinceYield++;
    const now = performance.now();
    if (now - lastYield > targetChunkMs && iterSinceYield >= batchSize) {
      // ajuster le batch en fonction du temps r√©el
      const spent = now - lastYield;
      if (spent < targetChunkMs / 2 && batchSize < maxBatch) {
        batchSize = Math.min(maxBatch, batchSize * 2);
      } else if (spent > targetChunkMs * 2 && batchSize > minBatch) {
        batchSize = Math.max(minBatch, Math.floor(batchSize / 2));
      }
      lastYield = now;
      iterSinceYield = 0;

      progress({ phase: "A->B", done: i + 1, total: nA + nB });
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
  }

  progress({ phase: "A->B", done: nA, total: nA + nB });

  // reset pour la deuxi√®me boucle
  batchSize = Math.max(minBatch, batchSize);
  lastYield = performance.now();
  iterSinceYield = 0;

  // ---------------- B -> A ----------------
  for (let j = 0; j < nB; j++) {
    let bestScore = 0;
    let bestIdx = null;

    for (let i = 0; i < nA; i++) {
      const s1 = cosineSimilarity(vecB[j], vecA[i]);
      const s2 = fuzzySimilarity(listB[j], listA[i]);
      const score = alpha * s1 + beta * s2;
      if (score > bestScore) {
        bestScore = score;
        bestIdx = i;
      }
    }

    matchesFromB.push({
      fromIndex: j,
      toIndex: bestScore >= threshold ? bestIdx : null,
      score: bestScore
    });

    iterSinceYield++;
    const now = performance.now();
    if (now - lastYield > targetChunkMs && iterSinceYield >= batchSize) {
      const spent = now - lastYield;
      if (spent < targetChunkMs / 2 && batchSize < maxBatch) {
        batchSize = Math.min(maxBatch, batchSize * 2);
      } else if (spent > targetChunkMs * 2 && batchSize > minBatch) {
        batchSize = Math.max(minBatch, Math.floor(batchSize / 2));
      }
      lastYield = now;
      iterSinceYield = 0;

      progress({ phase: "B->A", done: nA + j + 1, total: nA + nB });
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
  }

  progress({ phase: "B->A", done: nA + nB, total: nA + nB });

  updateStats(nA, nB, vocabSize, threshold);
  return { matchesFromA, matchesFromB, vocabSize };
}

    // ---------------------------------------------------
    // UI state, rendering & YAML export
    // ---------------------------------------------------

    const listAEl = document.getElementById("listA");
    const listBEl = document.getElementById("listB");
    const analyzeBtn = document.getElementById("analyzeBtn");
    const viewAEl = document.getElementById("viewA");
    const viewBEl = document.getElementById("viewB");
    const resultsSummaryEl = document.getElementById("resultsSummary");
    const countAEl = document.getElementById("countA");
    const countBEl = document.getElementById("countB");
    const statsCountsEl = document.getElementById("stats-counts");
    const statsVocabEl = document.getElementById("stats-vocab");
    const statsThresholdEl = document.getElementById("stats-threshold");
    const glossaryEl = document.getElementById("glossary");
    const glossaryFileInput = document.getElementById("glossaryFile");

    if (glossaryFileInput) {
      glossaryFileInput.addEventListener("change", (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          glossaryEl.value = ev.target.result || "";
        };
        reader.readAsText(file);
      });
    }

    window.__lastLists = {
      listA: [],
      listB: []
    };
    window.__lastResult = {
      matchesFromA: [],
      matchesFromB: [],
      vocabSize: 0
    };

    function updateStats(nA, nB, vocabSize, threshold) {
      statsCountsEl.textContent = `${nA} item(s) in list 1 ¬∑ ${nB} item(s) in list 2`;

      if (vocabSize > 0) {
        statsVocabEl.textContent = `Vocabulary: ${vocabSize} distinct terms`;
      } else {
        statsVocabEl.textContent = "Vocabulary: ‚Äî distinct terms";
      }

      statsThresholdEl.textContent = `Match threshold: ${threshold.toFixed(2)}`;
    }

function parseList(text) {
  return (text || "")
    .split(/\r?\n/)             // ICI : \r?\n
    .map((l) => l.trim())
    .filter((l) => l.length > 0);
}


    function formatScore(score) {
      if (!Number.isFinite(score)) return "0.00";
      return score.toLocaleString("en-US", {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      });
    }

    function escapeHtml(str) {
      return String(str || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    function renderMatchesInternal(listA, listB, result) {
      const { matchesFromA, matchesFromB } = result;

      countAEl.textContent = listA.length;
      countBEl.textContent = listB.length;

      if (listA.length === 0 || listB.length === 0) {
        resultsSummaryEl.textContent = "Add at least one item in each list, then run the analysis.";
      } else {
        const matchedCountA = matchesFromA.filter((m) => m.toIndex !== null).length;
        const matchedCountB = matchesFromB.filter((m) => m.toIndex !== null).length;
        resultsSummaryEl.textContent =
          `Detected matches: ${matchedCountA}/${listA.length} from list 1, ` +
          `${matchedCountB}/${listB.length} from list 2.`;
      }

      // View A -> B: only show items that have a match
      if (listA.length === 0) {
        viewAEl.innerHTML = `<div class="empty-state">Enter a few lines in list 1 to get started.</div>`;
      } else {
        const rows = matchesFromA
          .filter((m) => m.toIndex !== null && listB[m.toIndex])
          .map((m) => {
            const leftText = escapeHtml(listA[m.fromIndex] || "");
            const rightText = escapeHtml(listB[m.toIndex] || "");

            const labelLeft = `L1 #${m.fromIndex + 1}`;
            const labelRight = `L2 #${m.toIndex + 1}`;

            return `
              <div class="match-row">
                <div class="item-card">
                  <div class="item-label">
                    <span><strong>${labelLeft}</strong></span>
                    <span class="score-pill">
                      score: <strong>${formatScore(m.score)}</strong>
                    </span>
                  </div>
                  <div class="item-text">${leftText}</div>
                </div>
                <div class="arrow-cell" aria-hidden="true">
                  <div class="arrow-pill">‚ûù</div>
                </div>
                <div class="item-card">
                  <div class="item-label">
                    <span><strong>${labelRight}</strong></span>
                  </div>
                  <div class="item-text">${rightText}</div>
                </div>
              </div>
            `;
          })
          .join("");

        viewAEl.innerHTML =
          rows || `<div class="empty-state">No matches have been detected.</div>`;
      }

      // View B -> A: only show items that have a match
      if (listB.length === 0) {
        viewBEl.innerHTML = `<div class="empty-state">Enter a few lines in list 2 to get started.</div>`;
      } else {
        const rowsB = matchesFromB
          .filter((m) => m.toIndex !== null && listA[m.toIndex])
          .map((m) => {
            const leftText = escapeHtml(listB[m.fromIndex] || "");
            const rightText = escapeHtml(listA[m.toIndex] || "");

            const labelLeft = `L2 #${m.fromIndex + 1}`;
            const labelRight = `L1 #${m.toIndex + 1}`;

            return `
              <div class="match-row">
                <div class="item-card">
                  <div class="item-label">
                    <span><strong>${labelLeft}</strong></span>
                    <span class="score-pill">
                      score: <strong>${formatScore(m.score)}</strong>
                    </span>
                  </div>
                  <div class="item-text">${leftText}</div>
                </div>
                <div class="arrow-cell" aria-hidden="true">
                  <div class="arrow-pill">‚ûù</div>
                </div>
                <div class="item-card">
                  <div class="item-label">
                    <span><strong>${labelRight}</strong></span>
                  </div>
                  <div class="item-text">${rightText}</div>
                </div>
              </div>
            `;
          })
          .join("");

        viewBEl.innerHTML =
          rowsB || `<div class="empty-state">No matches have been detected.</div>`;
      }
    }

    window.renderMatches = function (listA, listB, result) {
      renderMatchesInternal(listA, listB, result);
    };

    // Initial stats
    updateStats(0, 0, 0, MATCH_THRESHOLD);

    function refreshLiveStats() {
      const listA = parseList(listAEl.value);
      const listB = parseList(listBEl.value);
      updateStats(listA.length, listB.length, 0, MATCH_THRESHOLD);
    }

    listAEl.addEventListener("input", refreshLiveStats);
    listBEl.addEventListener("input", refreshLiveStats);

    // Analysis button
    analyzeBtn.addEventListener("click", async () => {
      const rawListA = parseList(listAEl.value);
      const rawListB = parseList(listBEl.value);

      const glossaryText = glossaryEl ? glossaryEl.value : "";
      const glossaryPairs = parseGlossary(glossaryText);

      // Enriched lists for similarity computation
      const listAForSimilarity = rawListA.map((line) =>
        applyGlossaryToSentence(line, glossaryPairs)
      );
      const listBForSimilarity = rawListB.map((line) =>
        applyGlossaryToSentence(line, glossaryPairs)
      );

      window.__lastLists = {
        listA: rawListA.slice(),
        listB: rawListB.slice()
      };

      if (rawListA.length === 0 || rawListB.length === 0) {
        updateStats(rawListA.length, rawListB.length, 0, MATCH_THRESHOLD);
        resultsSummaryEl.textContent = "Please provide at least one item in both lists.";
        const emptyResult = {
          matchesFromA: [],
          matchesFromB: [],
          vocabSize: 0
        };
        window.__lastResult = emptyResult;
        window.renderMatches(rawListA, rawListB, emptyResult);
        return;
      }

      analyzeBtn.disabled = true;
      analyzeBtn.innerHTML =
        `<span class="icon" aria-hidden="true">‚è≥</span><span>Analysis in progress‚Ä¶</span>`;

      try {
        const result = await computeMatches(
          listAForSimilarity,
          listBForSimilarity,
          MATCH_THRESHOLD,
          (info) => {
            // info.phase = "prepare" | "A->B" | "B->A" | "USE"
            // info.done / info.total -> pourcentage global
    
            const pct =
              info && info.total
                ? Math.round((info.done / info.total) * 100)
                : 0;
    
            let phaseLabel = "";
            if (info.phase === "prepare") phaseLabel = "Pr√©paration des donn√©es";
            else if (info.phase === "A->B") phaseLabel = "Analyse liste 1 ‚Üí liste 2";
            else if (info.phase === "B->A") phaseLabel = "Analyse liste 2 ‚Üí liste 1";
            else if (info.phase === "USE") phaseLabel = "Analyse s√©mantique (USE)";
    
            resultsSummaryEl.textContent =
              `${phaseLabel}‚Ä¶ (${pct}%)`;
          }
        );
    
        window.__lastResult = result;
        window.renderMatches(rawListA, rawListB, result);
      } catch (err) {
        console.error("Error during analysis:", err);
        resultsSummaryEl.textContent =
          "‚ö†Ô∏è Error during analysis (see console for details).";
        const emptyResult = {
          matchesFromA: [],
          matchesFromB: [],
          vocabSize: 0
        };
        window.__lastResult = emptyResult;
        window.renderMatches(rawListA, rawListB, emptyResult);
      } finally {
        analyzeBtn.disabled = false;
        analyzeBtn.innerHTML =
          `<span class="icon" aria-hidden="true">‚ûú</span><span>Run the analysis again</span>`;
      }

      
    });

    // Accessible tabs
    document.querySelectorAll(".tab-button").forEach((btn) => {
      btn.addEventListener("click", () => {
        const tab = btn.getAttribute("data-tab");

        document.querySelectorAll(".tab-button").forEach((b) => {
          const isActive = b === btn;
          b.classList.toggle("active", isActive);
          b.setAttribute("aria-selected", isActive ? "true" : "false");
          b.tabIndex = isActive ? 0 : -1;
        });

        document.querySelectorAll(".results-list").forEach((list) => {
          list.classList.toggle("active", list.id === tab);
        });
      });

      btn.addEventListener("keydown", (event) => {
        if (event.key !== "ArrowLeft" && event.key !== "ArrowRight") return;
        event.preventDefault();
        const tabs = Array.from(document.querySelectorAll(".tab-button"));
        const index = tabs.indexOf(btn);
        if (index === -1) return;
        const direction = event.key === "ArrowRight" ? 1 : -1;
        let nextIndex = index + direction;
        if (nextIndex < 0) nextIndex = tabs.length - 1;
        if (nextIndex >= tabs.length) nextIndex = 0;
        tabs[nextIndex].click();
        tabs[nextIndex].focus();
      });
    });
  </script>

  <script>
    // ---------------------------------------------------
    // YAML export integration
    // ---------------------------------------------------
    (function () {
      if (typeof window.renderMatches !== "function") return;

      const originalRenderMatches = window.renderMatches;
      window.__matchExportData = null;

      window.renderMatches = function (listA, listB, result) {
        window.__matchExportData = {
          listA: Array.isArray(listA) ? listA.slice() : [],
          listB: Array.isArray(listB) ? listB.slice() : [],
          matchesFromA:
            result && Array.isArray(result.matchesFromA)
              ? result.matchesFromA.map((m) => ({ ...m }))
              : [],
          matchesFromB:
            result && Array.isArray(result.matchesFromB)
              ? result.matchesFromB.map((m) => ({ ...m }))
              : []
        };
        return originalRenderMatches(listA, listB, result);
      };

    function toYamlScalar(str) {
      const oneLine = String(str || "").replace(/\r?\n/g, " "); // ICI : \r?\n
      const escaped = oneLine.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
      return `"${escaped}"`;
    }

      function downloadText(filename, text) {
        const blob = new Blob([text], { type: "text/yaml;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(function () {
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }, 0);
      }

      // Build YAML for current view ("A" for list1, "B" for list2)
      function buildYaml(view, data) {
        const { listA, listB, matchesFromA, matchesFromB } = data || {};

        if (view === "A") {
          if (!Array.isArray(listA) || !Array.isArray(matchesFromA)) {
            return "list1: []\\n";
          }

          const rootKey = "list1";
          const lines = [];
          lines.push(rootKey + ":");

          const filtered = matchesFromA.filter(
            (m) => m.toIndex !== null && listB && listB[m.toIndex]
          );

          if (filtered.length === 0) {
            return "list1: []\\n";
          }

          filtered.forEach(function (m) {
            const parentText = listA[m.fromIndex] || "";
            const childText = listB[m.toIndex] || "";

            lines.push("  - parent: " + toYamlScalar(parentText));
            lines.push("    children:");
            lines.push("      - " + toYamlScalar(childText));
          });

          return lines.join("\\n") + "\\n";
        } else {
          if (!Array.isArray(listB) || !Array.isArray(matchesFromB)) {
            return "list2: []\\n";
          }

          const rootKey = "list2";
          const lines = [];
          lines.push(rootKey + ":");

          const filtered = matchesFromB.filter(
            (m) => m.toIndex !== null && listA && listA[m.toIndex]
          );

          if (filtered.length === 0) {
            return "list2: []\\n";
          }

          filtered.forEach(function (m) {
            const parentText = listB[m.fromIndex] || "";
            const childText = listA[m.toIndex] || "";

            lines.push("  - parent: " + toYamlScalar(parentText));
            lines.push("    children:");
            lines.push("      - " + toYamlScalar(childText));
          });

          return lines.join("\\n") + "\\n";
        }
      }

      const resultsHeader = document.querySelector(".results-header");
      if (!resultsHeader) return;

      let currentView = "A"; // "A" = view by list1, "B" = view by list2

      const exportBtn = document.createElement("button");
      exportBtn.type = "button";
      exportBtn.className = "chip";
      exportBtn.style.cursor = "pointer";
      exportBtn.setAttribute("aria-label", "Export matches as YAML");

      function updateExportButtonLabel() {
        const icon = "‚á©";
        if (currentView === "A") {
          exportBtn.innerHTML = `<span>${icon}</span> Export list 1 (YAML)`;
        } else {
          exportBtn.innerHTML = `<span>${icon}</span> Export list 2 (YAML)`;
        }
      }

      function exportYamlForCurrentView() {
        const data = window.__matchExportData;
        if (
          !data ||
          !Array.isArray(data.listA) ||
          !Array.isArray(data.listB)
        ) {
          alert("Please run the analysis first to generate matches.");
          return;
        }

        const yaml = buildYaml(currentView, data);
        const filename =
          currentView === "A"
            ? "matches_list1.yaml"
            : "matches_list2.yaml";

        downloadText(filename, yaml);
      }

      exportBtn.addEventListener("click", exportYamlForCurrentView);

      const activeTab = document.querySelector(".tab-button.active");
      if (activeTab && activeTab.getAttribute("data-tab") === "viewB") {
        currentView = "B";
      }
      updateExportButtonLabel();

      resultsHeader.appendChild(exportBtn);

      document.querySelectorAll(".tab-button").forEach(function (btn) {
        btn.addEventListener("click", function () {
          const tab = btn.getAttribute("data-tab");
          currentView = tab === "viewB" ? "B" : "A";
          updateExportButtonLabel();
        });
      });
    })();
  </script>

  <script>
    // ---------------------------------------------------
    // Theme toggle using the two <style> blocks (dark & light)
    // ---------------------------------------------------
    (function () {
      const styleEls = Array.from(document.querySelectorAll("head style"));

      let darkStyle =
        styleEls.find((s) => s.textContent.includes("#0f172a")) || styleEls[0];
      let lightStyle = styleEls.find((s) => s !== darkStyle) || styleEls[1];

      const THEME_KEY = "listMatcherTheme";
      let currentTheme = localStorage.getItem(THEME_KEY);
      if (currentTheme !== "light" && currentTheme !== "dark") {
        currentTheme = "dark";
      }

      function updateToggleLabel(btn, theme) {
        if (!btn) return;
        if (theme === "dark") {
          btn.innerHTML = "‚òÄÔ∏è&nbsp;Light mode";
          btn.setAttribute("aria-pressed", "false");
        } else {
          btn.innerHTML = "üåô&nbsp;Dark mode";
          btn.setAttribute("aria-pressed", "true");
        }
        btn.setAttribute("aria-label", "Toggle light/dark theme");
      }

      function applyTheme(theme, toggleBtn) {
        currentTheme = theme;
        localStorage.setItem(THEME_KEY, theme);

        if (darkStyle && lightStyle) {
          if (theme === "light") {
            darkStyle.setAttribute("media", "not all");
            lightStyle.removeAttribute("media");
          } else {
            lightStyle.setAttribute("media", "not all");
            darkStyle.removeAttribute("media");
          }
        }

        document.documentElement.setAttribute("data-theme", theme);
        updateToggleLabel(toggleBtn, theme);
      }

      const header = document.querySelector(".app-header .header-actions");
      if (!header) return;

      const toggleBtn = document.createElement("button");
      toggleBtn.type = "button";
      toggleBtn.className = "chip";
      toggleBtn.style.cursor = "pointer";
      toggleBtn.setAttribute("role", "button");
      toggleBtn.setAttribute("aria-live", "polite");

      header.appendChild(toggleBtn);

      applyTheme(currentTheme, toggleBtn);

      toggleBtn.addEventListener("click", function () {
        const nextTheme = currentTheme === "dark" ? "light" : "dark";
        applyTheme(nextTheme, toggleBtn);
      });
    })();
  </script>
</body>
</html>
